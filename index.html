<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Paperfy</title>
<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
<script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: #0a0a0a;
    color: #f5f5f7;
    min-height: 100vh;
    overflow-x: hidden;
  }

  .grain {
    position: fixed; inset: 0; z-index: 0; pointer-events: none; opacity: 0.03;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
    background-size: 128px 128px;
  }

  .glass-card {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    backdrop-filter: blur(20px);
    border-radius: 20px;
  }

  .upload-zone {
    border: 2px dashed rgba(255,255,255,0.15);
    border-radius: 16px;
    transition: all 0.3s ease;
    cursor: pointer;
  }
  .upload-zone:hover, .upload-zone.dragover {
    border-color: rgba(255,255,255,0.4);
    background: rgba(255,255,255,0.05);
  }

  .toggle-track {
    width: 200px; height: 44px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 22px;
    position: relative;
    cursor: pointer;
  }
  .toggle-thumb {
    position: absolute; top: 3px; left: 3px;
    width: 97px; height: 38px;
    background: #fff;
    border-radius: 19px;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  .toggle-track.animated .toggle-thumb {
    transform: translateX(97px);
  }
  .toggle-label {
    position: absolute; top: 50%; transform: translateY(-50%);
    font-size: 13px; font-weight: 600;
    transition: color 0.3s;
    z-index: 1;
  }
  .toggle-label.left { left: 24px; }
  .toggle-label.right { right: 18px; }
  .toggle-track .toggle-label.left { color: #000; }
  .toggle-track .toggle-label.right { color: rgba(255,255,255,0.5); }
  .toggle-track.animated .toggle-label.left { color: rgba(255,255,255,0.5); }
  .toggle-track.animated .toggle-label.right { color: #000; }

  .slider-container input[type="range"] {
    -webkit-appearance: none; appearance: none;
    width: 100%; height: 4px;
    background: rgba(255,255,255,0.15);
    border-radius: 2px; outline: none;
  }
  .slider-container input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 20px; height: 20px;
    background: #fff;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  .thickness-slider input[type="range"] {
    -webkit-appearance: none; appearance: none;
    width: 100%; height: 4px;
    background: rgba(255,255,255,0.15);
    border-radius: 2px; outline: none;
  }
  .thickness-slider input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 20px; height: 20px;
    background: #fff;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  .btn-primary {
    background: #fff; color: #000;
    font-weight: 600; font-size: 15px;
    padding: 14px 32px;
    border-radius: 12px; border: none;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .btn-primary:hover { background: #e0e0e0; transform: scale(0.98); }
  .btn-primary:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }

  .preview-area {
    background: repeating-conic-gradient(rgba(255,255,255,0.05) 0% 25%, transparent 0% 50%) 0 0 / 20px 20px;
    border-radius: 16px;
    min-height: 300px;
    display: flex; align-items: center; justify-content: center;
    position: relative; overflow: hidden;
  }
  .preview-area img, .preview-area canvas {
    max-width: 100%; max-height: 500px; object-fit: contain;
  }

  .fade-in { animation: fadeIn 0.5s ease forwards; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

  .spinner {
    width: 32px; height: 32px;
    border: 3px solid rgba(255,255,255,0.1);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  .hero-glow {
    position: absolute; top: -200px; left: 50%; transform: translateX(-50%);
    width: 600px; height: 400px;
    background: radial-gradient(ellipse, rgba(255,255,255,0.06) 0%, transparent 70%);
    pointer-events: none;
  }
</style>
</head>
<body>
<div class="grain"></div>

<div class="relative z-10 max-w-3xl mx-auto px-6 py-16">
  <!-- Hero -->
  <div class="relative text-center mb-16">
    <div class="hero-glow"></div>
    <h1 class="text-5xl font-bold tracking-tight mb-3" style="letter-spacing:-0.03em;">Paperfy</h1>
    <p class="text-lg text-white/40 font-light">Transform any shape into a wrinkled paper outline.</p>
  </div>

  <!-- Upload -->
  <div class="glass-card p-8 mb-8 fade-in">
    <div class="upload-zone p-12 text-center" id="uploadZone">
      <input type="file" id="fileInput" accept="image/png" class="hidden">
      <div id="uploadContent">
        <svg class="mx-auto mb-4" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="17 8 12 3 7 8"/>
          <line x1="12" y1="3" x2="12" y2="15"/>
        </svg>
        <p class="text-white/50 text-sm">Drop your PNG here or <span class="text-white/80 underline">browse</span></p>
        <p class="text-white/25 text-xs mt-2">Transparent PNG works best</p>
      </div>
      <div id="uploadedInfo" class="hidden">
        <p class="text-white/70 text-sm" id="fileName"></p>
        <p class="text-white/30 text-xs mt-1">Click to change</p>
      </div>
    </div>
  </div>

  <!-- Controls -->
  <div class="glass-card p-8 mb-8 fade-in" style="animation-delay:0.1s;" id="controlsCard">
    <div class="flex flex-col items-center gap-8">
      <!-- Mode toggle -->
      <div>
        <p class="text-xs text-white/30 uppercase tracking-widest mb-3 text-center">Mode</p>
        <div class="toggle-track" id="modeToggle">
          <div class="toggle-thumb"></div>
          <span class="toggle-label left">Still</span>
          <span class="toggle-label right">Animated</span>
        </div>
      </div>

      <!-- Outline thickness -->
      <div class="w-full max-w-xs thickness-slider">
        <div class="flex justify-between mb-2">
          <p class="text-xs text-white/30 uppercase tracking-widest">Outline Thickness</p>
          <span class="text-xs text-white/50" id="thicknessValue">3px</span>
        </div>
        <input type="range" id="thicknessSlider" min="1" max="20" value="3">
      </div>

      <!-- Interval (animated only) -->
      <div class="w-full max-w-xs slider-container hidden" id="intervalControl">
        <div class="flex justify-between mb-2">
          <p class="text-xs text-white/30 uppercase tracking-widest">Frame Interval</p>
          <span class="text-xs text-white/50" id="intervalValue">500ms</span>
        </div>
        <input type="range" id="intervalSlider" min="50" max="2000" value="500" step="50">
      </div>

      <!-- Generate -->
      <button class="btn-primary" id="generateBtn" disabled>Generate</button>
    </div>
  </div>

  <!-- Preview -->
  <div class="glass-card p-8 fade-in hidden" style="animation-delay:0.2s;" id="previewCard">
    <div class="flex justify-between items-center mb-4">
      <p class="text-xs text-white/30 uppercase tracking-widest">Result</p>
      <button class="btn-primary text-sm !py-2 !px-5" id="downloadBtn" style="font-size:13px;">Download</button>
    </div>
    <div class="preview-area" id="previewArea">
      <p class="text-white/20 text-sm" id="previewPlaceholder">Your result will appear here</p>
    </div>
  </div>

  <!-- Footer -->
  <p class="text-center text-white/15 text-xs mt-12">Paperfy — Made with precision.</p>
</div>

<script>
  // --- ELEMENTS ---
  const uploadZone = document.getElementById('uploadZone');
  const fileInput = document.getElementById('fileInput');
  const uploadContent = document.getElementById('uploadContent');
  const uploadedInfo = document.getElementById('uploadedInfo');
  const fileNameEl = document.getElementById('fileName');
  const modeToggle = document.getElementById('modeToggle');
  const intervalControl = document.getElementById('intervalControl');
  const intervalSlider = document.getElementById('intervalSlider');
  const intervalValue = document.getElementById('intervalValue');
  const thicknessSlider = document.getElementById('thicknessSlider');
  const thicknessValue = document.getElementById('thicknessValue');
  const generateBtn = document.getElementById('generateBtn');
  const previewCard = document.getElementById('previewCard');
  const previewArea = document.getElementById('previewArea');
  const previewPlaceholder = document.getElementById('previewPlaceholder');
  const downloadBtn = document.getElementById('downloadBtn');

  let uploadedImage = null;
  let isAnimated = false;
  let resultBlob = null;
  let resultFileName = '';

  const PAPER_URL_1 = 'https://raw.githubusercontent.com/corrodedfridge-tech/paperfy/main/animatedpaper/wrinkleduppaper1.png';
  const PAPER_URL_2 = 'https://raw.githubusercontent.com/corrodedfridge-tech/paperfy/main/animatedpaper/wrinkleduppaper2.png';

  let paperImg1 = null;
  let paperImg2 = null;

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  // Preload paper textures
  Promise.all([loadImage(PAPER_URL_1), loadImage(PAPER_URL_2)]).then(([p1, p2]) => {
    paperImg1 = p1;
    paperImg2 = p2;
  }).catch(e => console.warn('Paper textures failed to load:', e));

  // --- UPLOAD ---
  uploadZone.addEventListener('click', () => fileInput.click());
  uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('dragover'); });
  uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
  uploadZone.addEventListener('drop', e => {
    e.preventDefault();
    uploadZone.classList.remove('dragover');
    if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
  });
  fileInput.addEventListener('change', () => { if (fileInput.files.length) handleFile(fileInput.files[0]); });

  function handleFile(file) {
    if (!file.type.includes('png')) { alert('Please upload a PNG file.'); return; }
    const reader = new FileReader();
    reader.onload = e => {
      const img = new Image();
      img.onload = () => {
        uploadedImage = img;
        uploadContent.classList.add('hidden');
        uploadedInfo.classList.remove('hidden');
        fileNameEl.textContent = file.name + ' (' + img.width + '×' + img.height + ')';
        generateBtn.disabled = false;
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }

  // --- MODE TOGGLE ---
  modeToggle.addEventListener('click', () => {
    isAnimated = !isAnimated;
    modeToggle.classList.toggle('animated', isAnimated);
    intervalControl.classList.toggle('hidden', !isAnimated);
  });

  intervalSlider.addEventListener('input', () => {
    intervalValue.textContent = intervalSlider.value + 'ms';
  });

  thicknessSlider.addEventListener('input', () => {
    thicknessValue.textContent = thicknessSlider.value + 'px';
  });

  // --- OUTLINE EXTRACTION ---
  // Creates a mask that is ONLY the outline (edge pixels) of the opaque region
  function createOutlineMask(sourceImg, thickness) {
    const w = sourceImg.width;
    const h = sourceImg.height;

    // Get alpha channel of source
    const srcCanvas = document.createElement('canvas');
    srcCanvas.width = w; srcCanvas.height = h;
    const srcCtx = srcCanvas.getContext('2d');
    srcCtx.drawImage(sourceImg, 0, 0);
    const srcData = srcCtx.getImageData(0, 0, w, h);
    const alpha = srcData.data;

    // Build binary alpha map (1 = opaque, 0 = transparent)
    const opaque = new Uint8Array(w * h);
    for (let i = 0; i < w * h; i++) {
      opaque[i] = alpha[i * 4 + 3] > 30 ? 1 : 0;
    }

    // Erode: a pixel is "interior" if ALL pixels within `thickness` radius are opaque
    const interior = new Uint8Array(w * h);
    const r = thickness;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const idx = y * w + x;
        if (!opaque[idx]) { interior[idx] = 0; continue; }
        let allOpaque = true;
        for (let dy = -r; dy <= r && allOpaque; dy++) {
          for (let dx = -r; dx <= r && allOpaque; dx++) {
            if (dx * dx + dy * dy > r * r) continue;
            const nx = x + dx, ny = y + dy;
            if (nx < 0 || nx >= w || ny < 0 || ny >= h) { allOpaque = false; break; }
            if (!opaque[ny * w + nx]) allOpaque = false;
          }
        }
        interior[idx] = allOpaque ? 1 : 0;
      }
    }

    // Outline = opaque AND NOT interior
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = w; maskCanvas.height = h;
    const maskCtx = maskCanvas.getContext('2d');
    const maskData = maskCtx.createImageData(w, h);
    for (let i = 0; i < w * h; i++) {
      if (opaque[i] && !interior[i]) {
        maskData.data[i * 4 + 0] = 255;
        maskData.data[i * 4 + 1] = 255;
        maskData.data[i * 4 + 2] = 255;
        maskData.data[i * 4 + 3] = 255;
      }
    }
    maskCtx.putImageData(maskData, 0, 0);
    return maskCanvas;
  }

  // Render one frame: paper texture clipped to outline mask
  function renderFrame(paperImg, sourceImg, thickness) {
    const w = sourceImg.width;
    const h = sourceImg.height;
    const outlineMask = createOutlineMask(sourceImg, thickness);

    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');

    // Draw the outline mask
    ctx.drawImage(outlineMask, 0, 0);

    // Use source-in to clip paper texture to the outline only
    ctx.globalCompositeOperation = 'source-in';

    // Tile the paper texture to cover the full canvas
    const pw = paperImg.width;
    const ph = paperImg.height;
    for (let ty = 0; ty < h; ty += ph) {
      for (let tx = 0; tx < w; tx += pw) {
        ctx.drawImage(paperImg, tx, ty);
      }
    }

    ctx.globalCompositeOperation = 'source-over';
    return canvas;
  }

  // --- GENERATE ---
  generateBtn.addEventListener('click', async () => {
    if (!uploadedImage) return;
    if (!paperImg1 || !paperImg2) {
      alert('Paper textures are still loading. Please wait a moment.');
      return;
    }

    generateBtn.disabled = true;
    generateBtn.textContent = 'Generating...';
    previewCard.classList.remove('hidden');
    previewArea.innerHTML = '<div class="spinner"></div>';

    const thickness = parseInt(thicknessSlider.value);

    // Small delay so UI updates
    await new Promise(r => setTimeout(r, 50));

    try {
      if (!isAnimated) {
        // STILL
        const canvas = renderFrame(paperImg1, uploadedImage, thickness);
        previewArea.innerHTML = '';
        previewArea.appendChild(canvas);
        canvas.toBlob(blob => {
          resultBlob = blob;
          resultFileName = 'paperfy-outline.png';
        }, 'image/png');
      } else {
        // ANIMATED GIF
        const interval = parseInt(intervalSlider.value);
        const frame1 = renderFrame(paperImg1, uploadedImage, thickness);
        const frame2 = renderFrame(paperImg2, uploadedImage, thickness);

        const gif = new GIF({
          workers: 2,
          quality: 10,
          width: uploadedImage.width,
          height: uploadedImage.height,
          workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js',
          transparent: 0x00000000,
        });

        gif.addFrame(frame1, { delay: interval, copy: true });
        gif.addFrame(frame2, { delay: interval, copy: true });

        gif.on('finished', blob => {
          resultBlob = blob;
          resultFileName = 'paperfy-outline.gif';
          const url = URL.createObjectURL(blob);
          previewArea.innerHTML = '';
          const img = document.createElement('img');
          img.src = url;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '500px';
          previewArea.appendChild(img);
          generateBtn.disabled = false;
          generateBtn.textContent = 'Generate';
        });

        gif.render();
        return; // button re-enabled in callback
      }
    } catch (e) {
      console.error(e);
      previewArea.innerHTML = '<p class="text-red-400 text-sm">Error generating result.</p>';
    }

    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate';
  });

  // --- DOWNLOAD ---
  downloadBtn.addEventListener('click', () => {
    if (!resultBlob) return;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(resultBlob);
    a.download = resultFileName;
    a.click();
  });
</script>
</body>
</html>
